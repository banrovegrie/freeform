% Chapter 7: Optimal Schedule
%
% OVERVIEW: This chapter constructs the optimal schedule and derives the runtime.
% Central result: T = O~(sqrt(N/d_0)) matches Grover lower bound.
% Critical caveat: requires knowing s* to exponential precision.
%
% NEEDS: Chapter 5 (H(s), A_1, A_2, s*, delta_s, g_min)
% NEEDS: Chapter 6 (Gap bounds in three regions)
% NEEDS: Chapter 4 (Adiabatic theorem concept)
%
% FORWARD: Chapter 8 proves computing s* is NP-hard/#P-hard
% FORWARD: Chapter 9 analyzes what happens without precise s*

% =============================================================================
% Section: The Adiabatic Theorem
% =============================================================================
% SOURCE: paper/v3-quantum.tex lines 356, 710-712
% SOURCE: Appendix Sec A.4 (theorem:adaptiveRate)
%
% Statement (informal):
% - If H(s) varies slowly, system stays near instantaneous ground state
% - "Slowly" means: |dH/ds * ds/dt| << g(s)^2
% - Final state has fidelity >= 1-epsilon with ground state
%
% Key refs (line 356):
% - Roland-Cerf (roland2004quantum): local adaptive schedule
% - van Dam (vandam2001powerful): necessity of local schedule
% - Cunningham et al. (cunningham2024eigenpath): phase randomization
%
% Generic result (lines 710-712):
% - Works for any twice-differentiable H(s) with known gap lower bound
% - Extends recent phase randomization results to continuous time
%
% TODO: State precise theorem from Appendix
% TODO: Distinguish from original Jansen-Ruskai-Seiler adiabatic theorem
%
% REVIEWER: technical_soundness - Theorem statement must be precise

% =============================================================================
% Section: Local Adaptive Schedule
% =============================================================================
% SOURCE: paper/v3-quantum.tex lines 356, 712, 722
%
% Key insight: slow down where gap is small
% - ds/dt proportional to g(s) (not g(s)^2)
% - Adiabatic condition: rate of change << gap^2
% - With ds/dt ~ g(s): need |dH/ds| * g(s) << g(s)^2, i.e., |dH/ds| << g(s)
%
% Why local schedule necessary (lines 356):
% - Uniform schedule (ds/dt = const) gives runtime ~ 1/g_min^2 * L
% - Local schedule integrates 1/g(s)^2 ds, concentrating time at minimum
%
% Roland-Cerf construction:
% - Originally for Grover's adiabatic algorithm
% - Generalized here to arbitrary diagonal H_z
%
% TODO: Derive the schedule explicitly: s(t) implicitly defined by integral
% TODO: Show why uniform schedule is suboptimal by factor
%
% REVIEWER: presentation_quality - Motivate before formula

% =============================================================================
% Section: Runtime as Integral
% =============================================================================
% SOURCE: paper/v3-quantum.tex lines 712, Appendix derivation
%
% Total runtime formula:
% T = C/epsilon * integral_0^1 (1/g(s)^2) ds
%
% where C is a constant from the adiabatic theorem.
%
% Structure:
% - Integral dominated by region where g(s) is smallest
% - Gap profile from Chapter 6 determines integrand
% - Split into three regions for analysis
%
% TODO: Derive from adiabatic theorem statement
% TODO: Show how epsilon dependence arises
%
% REVIEWER: technical_soundness - Integral formula is standard but verify

% =============================================================================
% Section: Splitting the Integral
% =============================================================================
% SOURCE: paper/v3-quantum.tex lines 723-730
%
% Three regions:
% 1. Left: [0, s* - delta_s) - gap ~ c_L * (s* - s)
% 2. Window: [s* - delta_s, s* + delta_s] - gap ~ g_min
% 3. Right: (s* + delta_s, 1] - gap ~ c_R * (s - s*)
%
% Gap bounds (restated from Chapter 6, lines 723-730):
%
% Left (s in I_{s<-}):
%   g(s) >= A_1(A_1+1)/A_2 * (s* - s)
%
% Window (s in I_{s*}):
%   g(s) >= g_min
%
% Right (s in I_{s->}):
%   g(s) >= Delta/30 * (s - s*)/(1 - s_0) + correction
%
% TODO: Show how bounds simplify integral calculation
%
% REVIEWER: technical_soundness - Must use exact bounds from paper

% =============================================================================
% Section: Left Region Contribution
% =============================================================================
%
% Gap bound: g(s) >= c_L * (s* - s), where c_L = A_1(A_1+1)/A_2
%
% Integral:
% integral_0^{s*-delta_s} (1/g(s)^2) ds
%   <= integral_0^{s*-delta_s} (1/(c_L * (s* - s))^2) ds
%   = 1/c_L^2 * [1/(s* - s)]_0^{s*-delta_s}
%   = 1/c_L^2 * (1/delta_s - 1/s*)
%
% For delta_s << s*:
%   ~ 1/c_L^2 * 1/delta_s
%
% Subdominant because:
% - 1/delta_s is large but c_L^2 is also large (contains A_1^2)
% - Net contribution is O(polylog) relative to window
%
% TODO: Work out explicit scaling
% TODO: Show how A_1, A_2 cancel to give log factor
%
% OPTION: Could merge left and right into single "tails" section

% =============================================================================
% Section: Window Region Contribution
% =============================================================================
% SOURCE: paper/v3-quantum.tex lines 731 (dominant factor)
%
% Gap bound: g(s) >= g_min throughout window
%
% Integral:
% integral_{s*-delta_s}^{s*+delta_s} (1/g(s)^2) ds
%   <= 2*delta_s / g_min^2
%
% This is the DOMINANT contribution.
%
% Substituting formulas:
% - delta_s = 2/(A_1+1)^2 * sqrt(d_0*A_2/N)
% - g_min = 2*A_1/(A_1+1) * sqrt(d_0/(N*A_2))
%
% Window contribution:
%   ~ delta_s / g_min^2
%   ~ (sqrt(A_2)/A_1^2) * sqrt(N/d_0) / Delta^2
%
% Key factors:
% - sqrt(N/d_0): Grover-like scaling
% - sqrt(A_2)/A_1^2: spectral correction
% - 1/Delta^2: appears from g_min formula
%
% TODO: Show calculation step by step
% TODO: Verify scaling matches Theorem 1
%
% REVIEWER: gap_bounds - CRITICAL: must verify window dominates

% =============================================================================
% Section: Right Region Contribution
% =============================================================================
%
% Gap bound: g(s) >= c_R * (s - s*), where c_R = Delta/(30*(1-s_0))
%
% Integral (similar to left):
% integral_{s*+delta_s}^1 (1/g(s)^2) ds
%   <= 1/c_R^2 * (1/delta_s - 1/(1-s*))
%   ~ 1/c_R^2 * 1/delta_s
%
% Subdominant for same reasons as left region.
%
% Note: Right region bound has correction term (lines 728-729)
% but dominant behavior is still linear in (s - s*).
%
% TODO: Account for correction term in analysis
%
% OPTION: Detailed calculation could go to appendix

% =============================================================================
% Section: Main Runtime Theorem
% =============================================================================
% SOURCE: paper/v3-quantum.tex lines 358-372 (Theorem 1, thm:main-result-1)
%
% Theorem 1 (Main Result 1):
% AQO prepares state with fidelity >= 1-epsilon with ground state superposition
% |v(1)> = (1/sqrt(d_0)) * sum_{z in Omega_0} |z>
% in time:
%
% T = O((1/epsilon) * (sqrt(A_2)/(A_1^2 * Delta^2)) * sqrt(2^n/d_0))
%
% Conditions:
% - |psi_0> = |+>^{otimes n} (equal superposition)
% - H_z satisfies Definition 1 (spectral condition)
%
% Proof (line 716): Apply generic adiabatic theorem (Appendix A.4) to AQO
%
% TODO: Break down where each factor comes from
% TODO: Verify window contribution gives this formula
%
% REVIEWER: complexity_claims - CRITICAL: runtime must match paper exactly

% =============================================================================
% Section: Grover Matching
% =============================================================================
% SOURCE: paper/v3-quantum.tex lines 374, 720-721
%
% For Ising Hamiltonians with Delta >= 1/poly(n):
% - A_1 = Theta(1) to poly(n)
% - A_2 = Theta(1) to poly(n)
% - sqrt(A_2)/(A_1^2 * Delta^2) = poly(n)
%
% Therefore: T = O~(sqrt(2^n/d_0))
%
% This matches Grover lower bound (line 721):
% - Farhi-Goldstone-Gutmann (farhi2008fail) lower bound: Omega(sqrt(N/d_0))
% - AQO achieves O~(sqrt(N/d_0)) (polylog overhead)
%
% Optimal for unstructured search:
% - No structure exploited beyond knowing d_0 solutions exist
% - Quadratic speedup over classical brute force
%
% TODO: Cite Farhi et al. lower bound precisely
% TODO: Discuss what "polylog overhead" means in practice
%
% REVIEWER: significance - This is the main positive result of the paper

% =============================================================================
% Section: The Hidden Assumption
% =============================================================================
% SOURCE: paper/v3-quantum.tex lines 722-737
%
% CRITICAL: The schedule construction requires knowing s*.
%
% Precision needed (lines 733-735):
% - s* must be known to precision O(delta_s)
% - delta_s = O(sqrt(d_0*A_2/N)) = O(2^{-n/2}) for typical cases
% - Equivalently: A_1 must be known to precision O(delta_s)
%
% Why this precision?
% - Gap bounds (lines 723-730) depend on (s - s*) or (s* - s)
% - If s* is wrong by more than delta_s, schedule misses the crossing
% - Runtime degrades from optimal
%
% What can be approximated (lines 731, 735):
% - A_2 can be replaced by lower bound (constant) - only poly(n) slowdown
% - d_0 = 1 assumption gives valid lower bound on g_min
% - A_1 CANNOT be approximated - it determines s* sensitively
%
% TODO: Show how much runtime degrades with imprecise s*
% TODO: Preview: this is where hardness enters
%
% FORWARD: Chapter 9 quantifies runtime vs precision tradeoff

% =============================================================================
% Section: The Information Cost
% =============================================================================
% SOURCE: paper/v3-quantum.tex lines 737-739, 376-378
%
% The key question (line 737):
% "How hard is it to compute A_1 to the desired additive precision?"
%
% Setting (line 739):
% - Assume adiabatic optimizer without access to gate-based quantum computer
% - Can use classical computation to pre-compute A_1
% - Question: Is classical computation tractable?
%
% Preview of hardness (lines 376-378):
% - NP-hard: even 1/poly(n) precision (much coarser than needed)
% - #P-hard: exponential precision O(2^{-poly(n)})
%
% The asymmetry (line 399):
% - Grover's algorithm (circuit model) achieves same speedup
% - But Grover doesn't need to pre-compute s*
% - AQO requires solving hard problem to achieve the speedup
%
% "Optimality with limitations" (line 399):
% - AQO is optimal IF you can solve NP-hard problem first
% - This is a fundamental limitation of the framework
%
% TODO: Set up the precise hardness question
% TODO: Explain why circuit model doesn't have this limitation
%
% FORWARD: Chapter 8 proves the hardness results
% FORWARD: Chapter 9 asks what can be done without full s* knowledge

% =============================================================================
% Section: Summary - What This Chapter Establishes
% =============================================================================
%
% Positive results:
% 1. Runtime T = O~(sqrt(N/d_0)) for Ising Hamiltonians
% 2. Matches Grover lower bound (optimal for unstructured search)
% 3. Local adaptive schedule achieves this
%
% The catch:
% 4. Schedule requires s* to exponential precision
% 5. s* = A_1/(A_1+1) depends sensitively on A_1
% 6. Computing A_1 precisely is the bottleneck
%
% Tension:
% - Optimality is theoretically achievable
% - But practical achievement requires solving hard problem
% - This is the "optimality with limitations" message
%
% REVIEWER: significance - Must convey both achievement and limitation
